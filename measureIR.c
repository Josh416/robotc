#pragma config(Sensor, S3,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          leftFront,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightFront,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "twoWheelMovement.c"
#include "hitechnic-sensormux.h"     //Drivers for IR Beacon
#include "hitechnic-irseeker-v2.h"
//#include "programs\functions\Common.c"
#include "IRsensor.c"


#include "JoystickDriver.c"

#define nxtOrange 3
#define nxtLeft 2
#define nxtRight 1
#define nxtGrey 0
#define noButton -1

float encoderValue;
string text;

// Function: waitForStartOrButton
// Parameters: NONE
// Outputs: NONE
// description: Waits till the start of the match or the touch of a button

void waitForStartOrButton()
{
	while (true)
	{
		getJoystickSettings(joystick);
		if (!joystick.StopPgm)      // normal FCS start condition
		{
			break;
		}

		if (nNxtButtonPressed == nxtOrange)
		{ // manual bypass start condition

			// 2 beeps and 2 seconds to get out of the way before the program starts
			playImmediateTone(1000,50);
			wait1Msec(1000);

			playImmediateTone(1000,50);
			wait1Msec(1000);

			break;
		}
	}
	return;
}


// Function: goIR
// Parameters:
//	Sensor: defines a sensor (AKA IR)
// Outputs: NONE
// description: Moves the robot till it is parallel to the IR beacon

void goIR(tSensors ir_seeker)
{
	int	ir_value = getIRReading(ir_seeker);
	repeatUntil(ir_value == 2)
	{
		backward(50);
		wait1Msec(1);
		ir_value = getIRReading(ir_seeker);
	}
}

// Function: calculateDist
// Parameters:
//	encodervalue: the value of a encoder
// Outputs: float
// description: calucates the of the robot via the encoder value

float calculateDist(const int encoderValue)
{
	float dist = encoderValue / CLICKSPERROTATION * CIRCUMFERENCE;
	return dist;
}

task main()
{
	//waitForStartOrButton();
	eraseDisplay();
	resetEncoders();
	goIR(IR);
	stopMotors();
	encoderValue = (nMotorEncoder[leftFront] + nMotorEncoder[rightFront]) / 2;
	sprintf(text, "encoder = %i", encoderValue);
	displayCenteredTextLine(1, text);
	sprintf(text, "distance = %f", calculateDist(encoderValue));
	displayCenteredTextLine(2, text);
	wait1Msec(10000);
	//	eraseDisplay();
}
