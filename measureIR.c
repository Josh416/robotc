#pragma config(Sensor, S3,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          leftFront,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightFront,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "functions\twoWheelMovement.c"
#include "drivers\hitechnic-sensormux.h"     //Drivers for IR Beacon
#include "drivers\hitechnic-irseeker-v2.h"
//#include "programs\functions\Common.c"


#include "JoystickDriver.c"

#define nxtOrange 3
#define nxtLeft 2
#define nxtRight 1
#define nxtGrey 0
#define noButton -1

float encoderValue;
string text;

void waitForStartOrButton()
{
	while (true)
	{
		getJoystickSettings(joystick);
		if (!joystick.StopPgm)      // normal FCS start condition
		{
			break;
		}

		if (nNxtButtonPressed == nxtOrange)
		{ // manual bypass start condition

			// 2 beeps and 2 seconds to get out of the way before the program starts
			playImmediateTone(1000,50);
			wait1Msec(1000);

			playImmediateTone(1000,50);
			wait1Msec(1000);

			break;
		}
	}
	return;
}

void resetEncoders()
{
	nMotorEncoder[rightFront] = 0;
	//nMotorEncoder[rightBack] = 0;
	nMotorEncoder[leftFront] = 0;
	//nMotorEncoder[leftBack] = 0;
}

int getIRReading(tSensors ir_seeker)
{
  wait1Msec(1);                              // Wait 1 ms
  int ir = HTIRS2readACDir(ir_seeker);      // IR receiver -> ir variable
  wait1Msec(1);                              // Down time before recheck
  return ir;
}

void goIR(tSensors ir_seeker)
{
	int	ir_value = getIRReading(ir_seeker);
	repeatUntil(ir_value == 2)
	{
		backward(50);
		wait1Msec(1);
		ir_value = getIRReading(ir_seeker);
	}
}

float calculateDist(const int encoderValue)
{
	float dist = encoderValue / 360.0 * CIRCUMFERENCE;
	return dist;
}

task main()
{
	//waitForStartOrButton();
	eraseDisplay();
	resetEncoders();
	goIR(IR);
	stopMotors();
	encoderValue = (nMotorEncoder[leftFront] + nMotorEncoder[rightFront]) / 2;
	sprintf(text, "encoder = %i", encoderValue);
	displayCenteredTextLine(1, text);
	sprintf(text, "distance = %f", calculateDist(encoderValue));
	displayCenteredTextLine(2, text);
	wait1Msec(10000);
//	eraseDisplay();
}
